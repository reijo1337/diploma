\section{Выделение контура фигуры}
\label{sec:Edge}

Для выделения контура кисти руки можно использовать операторы преобразования изображения. К таким методам можно отнести:

\begin{itemize}
	\item Оператор Собеля
	\item Оператор Прюитт
	\item Перекрестный оператор Робертса
	\item Оператор Кэнни
\end{itemize}

Рассмотрим каждый подробнее:

\subsection{Оператор Собеля}

Основная идея оператора Собеля\cite{Sobel} заключается в вычислении градиента освещенности каждой точки изображения. Вычисление производится примерное с помощью свертки изображения двумя сепарабельными целочисленными фильтрами размера 3x3 в вертикальном и горизонтальном направлениях. Благодаря этому вычисление работа данного оператора имеет низкие трудозатраты. В результате получаются два новых изображения Gx и Gy, в каждой точке которого записано приближенное значение производных по x и по y соответственно. Пусть A - исходное изображение, тогда вычисляются они следующим образом:

\begin{eqnarray}\label{eq:sobel-matrixs}
G_x = \begin{bmatrix}
-1 & 0 & 1\\
-2 & 0 & 2\\
-1 & 0 & 1\\
\end{bmatrix} \\
G_y = \begin{bmatrix}
-1 & -2 & -1\\
0 & 0 & 0\\
1 & 2 & 1\\
\end{bmatrix}
\end{eqnarray}

Определение данных матриц на языке Python выглядит следующим образом:

\begin{minipage}{0.75\textwidth}
	\begin{algorithm}[H]
		\lstinputlisting[language=Python]{src/sobel_matrix.py}
		\caption{Определение матриц свертки оператора Собелья}
		\label{imp:sobel-matrix}
	\end{algorithm}
\end{minipage}

В итоге значение градиента вычисляется как $G=\sqrt{G_x^2+G_y^2}$, а его направление как $\theta=\arctan(\frac{G_x}{G_y})$.

Для получения результата применем матрицы к изображению:


\begin{minipage}{0.75\textwidth}
	\begin{algorithm}[H]
		\lstinputlisting[language=Python]{src/sobel.py}
		\caption{Свертка изображения оператором Собеля}
		\label{imp:sobel}
	\end{algorithm}
\end{minipage}

Результат показывает скорость изменения яркости изображения в конкретной точке, т.е. вероятность ее нахождения на границе изображения.

\subsection{Оператор Прюитт}

Принцип работы\cite{Prewitt} аналогичен оператору Собеля, используются только другие ядра свертки:

\begin{eqnarray}\label{eq:prewitt-matrixs}
G_x = \begin{bmatrix}
-1 & 0 & 1\\
-1 & 0 & 1\\
-1 & 0 & 1\\
\end{bmatrix} \\
G_y = \begin{bmatrix}
-1 & -1 & -1\\
0 & 0 & 0\\
1 & 1 & 1\\
\end{bmatrix}
\end{eqnarray}

Отсюда реализация данного оператора отличается от реализации оператора Собеля только определением матриц:

\begin{minipage}{0.75\textwidth}
	\begin{algorithm}[H]
		\lstinputlisting[language=Python]{src/prewitt_matrix.py}
		\caption{Определение матриц свертки оператора Прюитт}
		\label{imp:prewitt-matrix}
	\end{algorithm}
\end{minipage}

\subsection{Перекрестный оператор Робертса}

Данный алгоритм\cite{Roberts} для каждого пиксела вычисляет сумму квадратов разниц со смежным ему диагональным пикселем. Данную операцию можно представить в виде свертки изображения двумя ядрами размера 2х2:

\begin{eqnarray}\label{eq:roberts-matrixs}
\begin{bmatrix}
1 & 0\\
0 & -1
\end{bmatrix} 
\begin{bmatrix}
0 & 1\\
-1 & 0
\end{bmatrix}
\end{eqnarray}

Подход данного метода не сильно отличается от двух рассмотренных ранее, в следствии чего его реализация выглядит следующим образом:

\begin{minipage}{0.75\textwidth}
	\begin{algorithm}[H]
		\lstinputlisting[language=Python]{src/roberts.py}
		\caption{Реализация перекрестного оператора Робертса}
		\label{imp:roberts}
	\end{algorithm}
\end{minipage}


В результате получается изображение пространственного градиента исходного изображения, где точки с наибольшим значением соответствуют границе.

\subsection{Оператор Кэнни}

Данный фильтр\cite{Canny} был разработан с учетом удовлетворения следующих свойств:
\begin{itemize}
	\item хорошее обнаружение (Кэнни трактовал это свойство как повышение отношения сигнал/шум);
	\item хорошая локализация (правильное определение положения границы);
	\item единственный отклик на одну границу.
\end{itemize}

Алгоритм состоит из пяти последовательных шагов:
\begin{enumerate}
	\item Размытие изображения для удаления лишнего шума.
	\item Поиск градиентов, для определения границ с максимальным значением градиента.
	\item Подавление не-максимумов, т.е. для границ берутся исключительно локальные максимумы.
	\item Определение потенциальных границ с помощью двойной пороговой фильтрации.
	\item Трассировка области неоднозначности
\end{enumerate}

Для получения размытого изображения можно использовать стандартную функцию $convolve()$ из пакета $scipy.ndimage.filters$. Для поиска градиентов подойдет оператор Собеля, описанный выше. 

Реализация подавления не-максимумов:

\begin{minipage}{0.75\textwidth}
	\begin{algorithm}[H]
		\lstinputlisting[language=Python]{src/canny_non_max.py}
		\caption{Функция подавления не-максимумов}
		\label{imp:canny-non-max}
	\end{algorithm}
\end{minipage}

Реализация опредления потенциальных границ:

\begin{minipage}{0.75\textwidth}
	\begin{algorithm}[H]
		\lstinputlisting[language=Python]{src/canny_threholding.py}
		\caption{Функция определения потенциальных}
		\label{imp:canny-threholding}
	\end{algorithm}
\end{minipage}

Финальным шагом является трассировка областей неоднозначности:

\begin{minipage}{0.75\textwidth}
	\begin{algorithm}[H]
		\lstinputlisting[language=Python]{src/canny_hysteresis.py}
		\caption{Трассировка области неоднозначности}
		\label{imp:canny-hysteresis}
	\end{algorithm}
\end{minipage}

Стоит обратить внимание, что описанные выше методы принимают на вход изображение в серых тонах. То есть нулевым шагом данных методов можно указать преобразование изображения из цветного в черно-белое.
